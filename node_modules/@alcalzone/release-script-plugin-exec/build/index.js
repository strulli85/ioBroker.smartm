import { DefaultStages } from "@alcalzone/release-script-core";
import { isArray, isObject } from "alcalzone-shared/typeguards";
class ExecPlugin {
    id = "exec";
    _stages = [];
    get stages() {
        return this._stages;
    }
    defineCLIOptions(yargs) {
        return yargs.options({
            exec: {
                alias: ["x"],
                description: `Define custom commands to be executed during the release process. Example:
--exec.before_commit="echo Hello World!"`,
            },
        });
    }
    init(context) {
        const commands = (context.argv.exec ?? {});
        if (isObject(commands) &&
            Object.keys(commands).every((c) => typeof c === "string") &&
            Object.values(commands).every((c) => typeof c === "string" || (isArray(c) && c.every((c) => typeof c === "string")))) {
            // Parse provided commands into stages
            const stages = new Map();
            for (const stage of Object.keys(commands)) {
                if (stages.has(stage))
                    continue;
                if (stage in DefaultStages) {
                    stages.set(stage, DefaultStages[stage]);
                }
                else if (stage.startsWith("before_")) {
                    const beforeStage = stage.substr(7);
                    const afterStages = Object.values(DefaultStages)
                        .filter((s) => s.before?.includes(beforeStage))
                        .map((s) => s.id);
                    // Make sure the before_xxx stages come after the previous stage and their after_xxx stages
                    afterStages.push(...(DefaultStages[beforeStage]?.after ?? []));
                    for (const afterStage of afterStages) {
                        if (`after_${afterStage}` in commands) {
                            afterStages.push(`after_${afterStage}`);
                        }
                    }
                    stages.set(stage, {
                        id: stage,
                        before: [beforeStage],
                        after: afterStages.length ? afterStages : undefined,
                    });
                }
                else if (stage.startsWith("after_")) {
                    const afterStage = stage.substr(6);
                    const beforeStages = Object.values(DefaultStages)
                        .filter((s) => s.after?.includes(afterStage))
                        .map((s) => s.id);
                    // Make sure the after_xxx stages come before the next stage and their before_xxx stages
                    beforeStages.push(...(DefaultStages[afterStage]?.before ?? []));
                    for (const beforeStage of beforeStages) {
                        if (`before_${beforeStage}` in commands) {
                            beforeStages.push(`before_${beforeStage}`);
                        }
                    }
                    stages.set(stage, {
                        id: stage,
                        before: beforeStages.length ? beforeStages : undefined,
                        after: [afterStage],
                    });
                }
                else {
                    stages.set(stage, {
                        id: stage,
                    });
                }
            }
            this.commands = commands;
            this._stages = [...stages.values()];
        }
        else {
            context.cli.fatal(`Argument "exec" is invalid. Must be an object containing strings or string arrays! Got ${JSON.stringify(commands)}`);
        }
    }
    // dependencies?: string[] | undefined;
    // stageAfter?: Record<string, ConstOrDynamic<string[]>> | undefined;
    // stageBefore?: Record<string, ConstOrDynamic<string[]>> | undefined;
    commands = {};
    async executeStage(context, stage) {
        let commands = this.commands[stage.id];
        if (!commands)
            return;
        // Normalize commands to an array
        if (typeof commands === "string") {
            commands = [commands];
        }
        // Execute commands
        const colors = context.cli.colors;
        for (const command of commands) {
            context.cli.logCommand(command);
            if (!context.argv.dryRun) {
                const promise = context.sys.execRaw(command, { cwd: context.cwd });
                promise.stdout?.on("data", (data) => {
                    context.cli.log(colors.gray(context.cli.stripColors(data.toString().replace(/\r?\n$/, ""))));
                });
                await promise;
            }
        }
    }
}
export default ExecPlugin;
//# sourceMappingURL=index.js.map